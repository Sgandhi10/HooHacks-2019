# -*- coding: utf-8 -*-
"""HooHacksProj.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NmEoULdxDb-eZvMX9zSSDYzTn_Hhe_-l
"""

import pandas as pd
aq = pd.read_csv("acqSubset.csv")
aq.head(3)
aq = aq.drop_duplicates(['loanID'],keep='last')
aq = aq.sort_values(by=['loanID'])
aq = aq.reset_index(drop=True)
aq = aq.set_index("loanID")
print(aq.shape)
#print(aq.at[100000433226, "orgUPB"])

pq = pd.read_csv("segmentak.csv")
pq = pq.drop_duplicates(['loanID'],keep='last')
pq = pq.sort_values(by=['loanID'])
pq = pq.reset_index(drop=True)
pq = pq.set_index("loanID")
print(pq.shape)
#print(pq)
#print(pq.at[888835647701, "loanAge"])

df = pd.concat([pq, aq], axis = 1, join = "inner")
#print(df.shape)
#print(df)
df = df.drop(['servicerName', 'maturityDate', "firstPaymentDate", 'propType', 'prodType', 'monthlyReportingPeriod', "miscHoldingExpnAndCredits", 'adjustedMonthsToMaturity','msa', 'modFlag','zeroBalEffDate','lastPaidInstallmentDate','foreclosureDate','dispositionDate','numUnits','propertyPreservationAndRepairCosts','assetRecoveryCosts', 'zeroBalCode','netSaleProceeds','repurchaseMakeWholeProceeds',	'otherForeclosureProceeds', 'assocTaxesForHoldingProperty', 'creditEnhancementProceeds','nonInterestBearingUPB','principalForgivenessAmt', 'reloMortIndicator','repurchaseMakeWholeProceedsFlag','ServicingActivityIndicator','origChannel','sellerName','coBorrowerCreditScoreAtOrigination','priMortgageInsurancePercent','mortInsType','foreclosureCosts','orgLTV','propertyState', 'zipCodeShort','foreclosurePrincipalWriteOffAmt','orginationDate'], axis=1)
#print(df)
df = df.reset_index(drop=True)
count = 0
#print(df)

import pandas as pd
import numpy as np
from keras.utils import to_categorical
from keras.models import Sequential
from keras.layers import Dense
from keras.callbacks import EarlyStopping

for i in range(df.shape[0]):
  if df.at[i, "currLoanDelinquencyStatus"] in ("X", "0"):
    df.at[i, "currLoanDelinquencyStatus"] = 0
  else:
    df.at[i, "currLoanDelinquencyStatus"] = 1
  if df.at[i, "firstTimeHomeBuyer"] == "Y":
    df.at[i, "firstTimeHomeBuyer"] = 1
  else:
    df.at[i, "firstTimeHomeBuyer"] = 0
  if df.at[i, "loanPurpose"] == "P":
    df.at[i, "loanPurpose"] = 2
  elif df.at[i, "loanPurpose"] == "C":
    df.at[i, "loanPurpose"] = 1
  else:
    df.at[i, "loanPurpose"] = 0
  if df.at[i, "occType"] == "P":
    df.at[i, "occType"] = 3
  elif df.at[i, "occType"] == "S":
    df.at[i, "occType"] = 2
  elif df.at[i, "occType"] == "I":
    df.at[i, "occType"] = 1
  else:
    df.at[i, "occType"] = 0
print(df.head(5))

from numpy import array
upperLimit = int(df.shape[0]*0.9)
trainData = df[:upperLimit]


train_x = trainData.drop(columns = ["currLoanDelinquencyStatus"]) #title of column that says whether they defaulted

train_y = to_categorical(trainData.currLoanDelinquencyStatus)
model = Sequential()
n_cols = train_x.shape[1]

model.add(Dense(250, activation = "relu", input_shape = (n_cols,)))
model.add(Dense(200, activation = "relu", input_shape = (n_cols,)))
model.add(Dense(150, activation = "relu", input_shape = (n_cols,)))
model.add(Dense(100, activation = "relu", input_shape = (n_cols,)))
model.add(Dense(50, activation = "relu", input_shape = (n_cols,)))

model.add(Dense(2, activation = "softmax"))

model.compile(optimizer="adam", loss = "categorical_crossentropy", metrics = ["accuracy"])

early_stopping_monitor = EarlyStopping(patience = 5)

model.fit(train_x, train_y, batch_size = 200, epochs = 200, validation_split=0.1, callbacks=[early_stopping_monitor])

def predictModel(L):
  #L = [currIntRate, currActualUPB, loanAge, remainingMonthsToLegalMaturity, origIntRate, orgUPB, orgLoanTerm, orgCombinedLTV, 
  #      numBorrowers, orgDebttoIncomeRatio, borrowerCreditScoreAtOrigination, firstTimeHomeBuyer, loanPurpose, occType]
  return model.predict(array([L]))
#test_data = df[upperLimit:]
#test_x = test_data.drop(columns = ["currLoanDelinquencyStatus"])
#print(test_x[0:10])
#test_y_predictions = predictModel([1,2,1,2,1,2,1,2,1,2,1,2,1,2])
#print(test_y_predictions)

#numCorrect = 0
#numWrong = 0
#for i in range(0, df.shape[0]-upperLimit):
#  if test_y_predictions[i][1] > 0.5:
#    if df.at[i,"currLoanDelinquencyStatus"] == 1:
#      numCorrect += 1
#    else:
#      numWrong += 1
#  else:
#    if df.at[i+upperLimit,"currLoanDelinquencyStatus"] == 1:
#      numWrong += 1
#    else:
#      numCorrect += 1
#print("Number of wrong guess:", numWrong)
#print("Number of correct guesses:", numCorrect)
#def pred(currIntRate, currActualUPB, loanAge, remainingMonthsToLegalMaturity, origIntRate, orgUPB, orgLoanTerm, orgCombinedLTV, 
#       numBorrowers, orgDebttoIncomeRatio, borrowerCreditScoreAtOrigination, firstTimeHomeBuyer, loanPurpose, occType):
#  return predict(array([currIntRate, currActualUPB, loanAge, remainingMonthsToLegalMaturity, origIntRate, orgUPB, orgLoanTerm, orgCombinedLTV, 
#        numBorrowers, orgDebttoIncomeRatio, borrowerCreditScoreAtOrigination, firstTimeHomeBuyer, loanPurpose, occType]))